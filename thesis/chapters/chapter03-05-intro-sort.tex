\newpage
\section{Intro Sort}
Głównym problemem wynikającym ze stosowania algorytmu Quick Sort jest jego słaba pesymistyczna złożoność obliczeniowa. Dla uporządkowanych danych wejściowych, głębokość drzewa wywołań rekurencyjnych jest równa rozmiarowi tablicy wejściowej, zaś sam algorytm działa w czasie równym $O(n^2)$. Dodatkowo, dla tablicy małych rozmiarów, algorytm Quick Sort powoduje niepotrzebny nakład czasowy, związany ze wstępnym przygotowaniem kolekcji. Obydwa te problemy rozwiązano stosując algorytm Intro Sort, którego analizę przedstawiono w bieżącym rozdziale.\\

Intro Sort, czyli sortowanie introspektywne, to algorytm hybrydowy będący połączeniem algorytmów Quick Sort, Insertion Sort oraz Heap Sort. Działanie algorytmu dostosowuje się w zależności od rozmiaru sortowanej tablicy oraz głębokości drzewa wywołań rekurencyjnych. Jeśli rozmiar tablicy jest mniejszy od punktu granicznego, kolekcja jest sortowana metodą Insertion Sort, wyznaczoną eksperymentalnie. Jeśli przekroczono maksymalną głębokość drzewa wywołań rekurencyjnych, łańcuch wywołań zostaje zakończony, zaś tablica zostaje posortowana metodą Heap Sort. Początkowa maksymalna głębokość drzewa wywołań rekurencyjnych jest wyznaczona wzorem $2\log{n}$. Ponieważ metoda Heap Sort działa z czasem $O(n\log{n})$ nawet w przypadku pesymistycznym, algorytm Intro Sort ma złożoność $O(n\log{n})$, niezależnie od porządku danych wejściowych.\\

Z powodu swojej wydajności, algorytm Intro Sort jest niezwykle popularny we współczesnych systemach komputerowych. Jego implementacja jest wykorzystywana między innymi w bibliotece standardowej libstdc jako funkcja sortująca \BOLD{std::sort}\footnote{Dokumentacja funkcji sortującej std::sort: \url{https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.4/a01027.html}}.\\

% TODO The Microsoft .NET Framework Class Library link

\subsection{Eksperymentalne wyznaczanie punktu granicznego}
Stosowanie rekurencyjnych metod sortujących, wykorzystujących technikę dziel i zwyciężaj, wiąże się z dodatkowym nakładem czasowym spowodowanym koniecznością odpowiedniego przygotowania tablicy przed jej posortowaniem. W przypadku algorytmu Quick Sort, dodatkowy nakład powoduje metoda partycjonowania. Z tego powodu, dla tablic o ograniczonym rozmiarze, bardziej wydajne okazuje się stosowanie elementarnych algorytmów sortujących.\\

Analizując liczbę wykonanych operacji dla elementarnych algorytmów sortujących (\ref{fig:sorting-small-array}) można zauważyć, że dla tablicy o rozmiarze nieprzekraczającym $19$ elementów, najbardziej wydajnym algorytmem jest Insertion Sort. Co więcej algorytm ten działa liniowo w przypadku uporządkowanych danych wejściowych. Z tego powodu algorytm Insertion Sort został zastosowany jako algorytm sortowania kolekcji o rozmiarze poniżej punktu granicznego. Punktem granicznym jest tablica rozmiaru $19$ elementów.\\

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=0.8\columnwidth]{img/plot/sorting-small-array.svg}
	\caption[]{}
	\label{fig:sorting-small-array}
\end{figure}

\subsection{Pseudokod}
Algorytm Intro Sort można podzielić na trzy rozłączne etapy. Wybór etapu uzależniony jest od wielkości tablicy wejściowej oraz głębokości drzewa wywołań rekurencyjnych. Dla tablicy o rozmiarze nieprzekraczającym punktu granicznego, dane są sortowane algorytmem Insertion Sort (linia \ref{line:insertion-sort}). Dla tablicy rozmiaru powyżej punktu granicznego, w przypadku gdy przekroczono maksymalną głębokość drzewa wywołań rekurencyjnych, stosowany jest algorytm Heap Sort (linia \ref{line:heap-sort}). W pozostałych sytuacjach stosowane jest klasyczne podejście z algorytmu Quick Sort (linia \ref{line:quick-sort}), przy czym każdemu rekurencyjnemu wywołaniu algorytmu towarzyszy dekrementacja głębokości drzewa.

\input{chapters/pseudocodes/intro-sort}

\subsection{Analiza deterministycznych wersji algorytmu Intro Sort}
Analizując wydajność deterministycznych algorytmów z rodziny Intro Sort, badano liczbę wykonywanych operacji atomowych z podziałem na operacje porównania, zamiany miejsc oraz przypisania. Badając łączną liczbę wykonanych operacji założono stałą wartość współczynnika kosztu $\alpha = 1.0$.\\

Dla losowych danych wejściowych (\ref{fig:intro-sort-deterministic-pivot-random}), sortowanie metodą Intro Sort jest wydajniejsze od algorytmu Quick Sort, niezależnie od metody partycjonowania oraz strategii wyboru piwota. Najlepsze wyniki otrzymano, łącząc algorytm Intro Sort z partycjonowaniem metodą Hoare oraz wyborem piwota jako mediana z trzech elementów. W przypadku partycjonowania metodą Lomuto, najlepsze wyniki otrzymano wybierając piwot jako pseudo-mediana z dziewięciu elementów oraz sortując algorytmem Intro Sort. Najmniej wydajną spośród badanych strategii jest wybór piwota jako mediana-median z pięciu elementów, przy czym najgorsze wyniki otrzymano niezależnie od wyboru metody partycjonowania.\\

Dla uporządkowanych danych wejściowych (\ref{fig:intro-sort-deterministic-pivot-reversed}), sortowanie metodą Intro Sort również jest wydajniejsze od algorytmu Quick Sort, niezależnie od metody partycjonowania oraz strategii wyboru piwota. Najwydajniejszym algorytmem sortującym dla tego typu danych wejściowych jest Intro Sort z metodą partycjonowania Hoare oraz wyborem piwota jako mediana z trzech elementów. Bardzo podobne wyniki otrzymano dla strategii wyboru piwota jako pseudo-mediana z dziewięciu elementów. W przypadku partycjonowania metodą Lomuto, najwydajniejszą strategią wyboru piwota jest pseudo-mediana z dziewięciu. Dla badanych algorytmów z rodziny Intro Sort, maksymalna złożoność obliczeniowa nie przekracza wartości $O(n\log{n})$, niezależnie od metody partycjonowania oraz strategii wyboru piwota. Jest to znacząca optymalizacja w stosunku do algorytmu Quick Sort, dla którego pesymistyczna złożoność obliczeniowa wynosi $O(n^2)$.\\

Analizując liczbę wykonanych operacji porównania (\ref{fig:intro-sort-deterministic-pivot-random-all}) dla losowych danych wejściowych można zauważyć, że dla takich samych strategii wyboru piwota, metoda Lomuto osiąga nieznacznie lepsze rezultaty niż partycjonowanie metodą Hoare. Najmniejszą liczbę operacji porównania otrzymano, partycjonując dane metodą Lomuto przy wyborze piwota jako pseudo-mediana z dziewięciu lub mediana z trzech elementów. Badając liczbę operacji zamiany miejsc można stwierdzić, że partycjonowanie metodą Hoare jest znacznie wydajniejsze niż partycjonowanie metodą Lomuto. Najmniejszą liczbę operacji zamiany miejsc otrzymano poprzez partycjonowanie metodą Hoare, przy wyborze piwota jako mediana-median z trzech.\\

Do analizy histogramu liczby wykonanych operacji (\ref{fig:intro-sort-deterministic-pivot-density}) użyto tablicy losowych danych o stałym rozmiarze $n = 1000$. Dla badanych algorytmów z rodziny Intro Sort, najmniejszą średnią liczbę wykonanych operacji otrzymano dla metody partycjonowania Hoare, przy wyborze piwota jako mediana z trzech oraz pseudo-mediana z dziewięciu elementów, jednak w przypadku pseudo-mediany z dziewięciu otrzymano znacznie mniejsze odchylenie standardowe. Dodatkowo, dla metody tej otrzymano najmniejsze odchylenie standardowe spośród wszystkich badanych strategii, więc jest to zalecana metoda wyboru piwota podczas sortowania algorytmem Intro Sort.\\

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/intro-sort-deterministic-pivot-random.svg}
	\caption[]{}
	\label{fig:intro-sort-deterministic-pivot-random}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/intro-sort-deterministic-pivot-reversed.svg}
	\caption[]{}
	\label{fig:intro-sort-deterministic-pivot-reversed}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=0.8\columnwidth]{img/plot/intro-sort-deterministic-pivot-density.svg}
	\caption[]{}
	\label{fig:intro-sort-deterministic-pivot-density}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.1\columnwidth]{img/plot/intro-sort-deterministic-pivot-random-all.svg}
	\caption[]{}
	\label{fig:intro-sort-deterministic-pivot-random-all}
\end{figure}

\subsection{Analiza randomizowanych wersji algorytmu Intro Sort}
Tak jak w poprzednim rozdziale, algorytmy były analizowane pod kątem liczby wykonywanych operacji atomowych, z podziałem na operacje porównania, zamiany miejsc oraz przypisania. Badając łączną liczbę wykonanych operacji założono stałą wartość współczynnika kosztu $\alpha = 1.0$.\\

Dla losowych danych wejściowych (\ref{fig:intro-sort-nondeterministic-pivot-random}), sortowanie metodą Intro Sort jest wydajniejsze od randomizowanego odpowiednika Quick Sort dla każdej badanej metody partycjonowania oraz strategii wyboru piwota. Najlepsze wyniki otrzymano, łącząc algorytm Intro Sort z partycjonowaniem metodą Hoare oraz wyborem piwota jako mediana z trzech losowych elementów lub pseudo-mediana z dziewięciu losowych elementów. Stosując algorytm Intro Sort, strategia wyboru piwota jako pseudo-mediana z dziewięciu losowych elementów jest również najlepsza przy partycjonowaniu metodą Lomuto. Co ciekawe, dla randomizowanych algorytmów Quick Sort, strategia ta osiąga najgorsze wyniki spośród badanych algorytmów.\\

Dla uporządkowanych danych wejściowych (\ref{fig:intro-sort-nondeterministic-pivot-reversed}), podobnie jak w przypadku danych losowych, sortowanie metodą Intro Sort jest wydajniejsze od randomizowanego odpowiednika Quick Sort, niezależnie od metody partycjonowania oraz strategii wyboru piwota. Dla obydwu metod partycjonowania, najlepsze wyniki otrzymano wybierając piwot jako pseudo-mediana z dziewięciu losowych elementów, przy czym stosując partycjonowanie metodą Hoare łączna liczba wykonanych operacji jest mniejsza niż w przypadku partycjonowania metodą Lomuto. Co ciekawe, strategia ta nie sprawdza się w przypadku randomizowanych algorytmów Quick Sort, dla których otrzymano najgorsze wyniki spośród badanych algorytmów.\\

Analizując liczbę wykonanych operacji porównania (\ref{fig:intro-sort-nondeterministic-pivot-random-all}) dla losowych danych wejściowych można zauważyć, że dla takich samych strategii wyboru piwota, metoda Lomuto osiąga nieznacznie lepsze rezultaty niż partycjonowanie metodą Hoare. Najmniejszą liczbę operacji porównania otrzymano, partycjonując dane metodą Lomuto przy wyborze piwota jako pseudo-mediana z dziewięciu lub mediana z trzech losowych elementów.
Najlepsze strategie wyboru piwota podczas minimalizacji liczby porównań okazują się również najlepszymi podczas minimalizacji liczby wykonywanych operacji zamiany miejsc. Badając liczbę operacji zamiany miejsc można stwierdzić, że partycjonowanie metodą Hoare jest znacznie wydajniejsze niż partycjonowanie metodą Lomuto.\\

Do analizy rozkładu prawdopodobieństwa liczby wykonanych operacji (\ref{fig:intro-sort-nondeterministic-pivot-density}) użyto tablicy losowych danych o stałym rozmiarze $n = 1000$. Dla badanych algorytmów z rodziny Intro Sort, najmniejszą wartość oczekiwaną liczby wykonanych operacji otrzymano dla metody partycjonowania Hoare, przy wyborze piwota jako pseudo-mediana z dziewięciu oraz mediana z trzech losowych elementów, jednak w przypadku pseudo-mediany z dziewięciu otrzymano znacznie mniejsze odchylenie standardowe. Fakt ten jest analogiczny w przypadku deterministycznych odpowiedników algorytmu Intro Sort. Dodatkowo, wybierając piwot jako pseudo-mediana z dziewięciu losowych elementów, otrzymano najmniejsze odchylenie standardowe spośród wszystkich randomizowanych strategii wyboru piwota.\\

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.1\columnwidth]{img/plot/intro-sort-nondeterministic-pivot-random-all.svg}
	\caption[]{}
	\label{fig:intro-sort-nondeterministic-pivot-random-all}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/intro-sort-nondeterministic-pivot-random.svg}
	\caption[]{}
	\label{fig:intro-sort-nondeterministic-pivot-random}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/intro-sort-nondeterministic-pivot-reversed.svg}
	\caption[]{}
	\label{fig:intro-sort-nondeterministic-pivot-reversed}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=0.8\columnwidth]{img/plot/intro-sort-nondeterministic-pivot-density.svg}
	\caption[]{}
	\label{fig:intro-sort-nondeterministic-pivot-density}
\end{figure}

\subsection{Wnioski}
TODO wnioski
% - Dla losowych danych wejściowych, zarówno Quick Sort jak i Intro Sort działają ze złożonością czasową $O(n\log{n})$, jednak Intro sort jest wydajniejszy,
% - Dla uporządkowanych danych wejściowych, algorytm Quick Sort może mieć kwadratową złożoność czasową $O(n^2)$. Problem ten rozwiązuje algorytm Intro Sort, dla którego złożoność czasowa jest rzędu $O(n\log{n})$, niezależnie od porządku wdanych wejściowych.
% - Intro Sort jest lepszy od Quick Sort zarówno dla losowych, jak i uporządkowanych danych wejściowych.
% - Intro Sort rozwiazuje problem z przypadkiem pesymistycznym dla Quick Sorta, działa maksymalnie ze złożonością $O(n\log{n})$.
