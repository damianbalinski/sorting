\chapter{Przegląd hybrydowych algorytmów sortujących}
\thispagestyle{chapterBeginStyle}

\section{Główne sposoby modyfikacji algorytmów}
W celu poprawy wydajności algorytmów sortujących stosuje się ich modyfikacje oraz ulepszenia. W tej pracy wykorzystano dwa główne sposoby na usprawnienie algorytmów.\\

Pierwszym sposobem jest modyfikacja składowych danego algorytmu. Wiele spośród znanych algorytmów składa się z kilku osobnych kroków, z których każdy można wyekstrahować do oddzielnego procesu. Pomysł ten polega na modyfikacji składowych algorytmu sortującego w taki sposób, aby np. lepiej radził on sobie w przypadku pesymistycznym.\\

Drugim sposobem na ulepszenie jest próba połączenia wielu algorytmów sortujących. Niektóre algorytmy zachowują się lepiej dla stosunkowo małej ilości danych, inne zaś są znaczenie wydajniejsze przy rozbudowanym zbiorze danych wejściowych. Pomysł ten polega na opracowaniu algorytmu, którego działanie zmienia się w zależności od czynników zewnętrznych, np. długości danych do posortowania.\\

\section{Rodzina deterministycznych algorytmów Quick Sort}
Podczas analizy algorytmów sortujących z rodziny Quick Sort zostały przetestowane wariacje algorytmów z różnymi metodami partycjonowania oraz różnymi deterministycznymi metodami wyboru pivota. Do partycjonowania danych wejściowych wykorzystano poniższe metody:

\begin{itemize}
	\setlength\itemsep{0em}
	\item \BOLD{metoda Lemuto} - jest domyślnym algorytmem partycjonowania w projektowanym systemie. Tablica jest iterowana od pierwszego do ostatniego elementu. Elementy mniejsze od pivota są przenoszone na lewą część tablicy, zaś elementy większe od pivota na jej prawą część. Algorytm kończy się w momencie przeniesienia ostatniego elementu.
	\item \BOLD{metoda Hoarego} - tablica jest partycjonowana za pomocą dwóch iteratorów umieszczonych po przeciwnych stronach tablicy oraz skierowanych do jej środka. Pojedyncza iteracja trwa do momentu napotkania dwóch elementów, które nie znajdują się w odpowiednich częściach tablicy, tzn. element po lewej stronie jest większy od pivota, oraz element po prawej stronie jest mniejszy od pivota. Wtedy elementy znajdujące się w miejscu iteratorów są zamieniane miejscami oraz algorytm jest kontynuowany. Program kończy się w momencie spotkania obydwu iteratorów.
\end{itemize}

Wykonując testy brano pod uwagę następujące metody wyboru pivota:
\begin{itemize}
	\setlength\itemsep{0em}
	\item \BOLD{ostatni element} - pivotem jest ostatni element tablicy,
	\item \BOLD{mediana z trzech} - pivotem jest mediana z pierwszego, środkowego oraz ostatniego elementu tablicy,
	\item \BOLD{pseudo-mediana z dziewięciu} - pivotem jest mediana z dziewięciu równo oddalonych od siebie elementów, z których pierwszym jest pierwszy element tablicy, oraz ostatnim jest ostatni element tablicy,
	\item \BOLD{mediana-median z pięciu} - pivot jest medianą pięciu median obliczanych rekurencyjnie,
	\item \BOLD{mediana-median z trzech} - pivot jest medianą trzech median obliczanych rekurencyjnie.\\
\end{itemize}

\subsection{Analiza porównawcza algorytmów}

Analizując wydajność algorytmów z rodziny Quick Sort badano liczbę wykonywanych operacji atomowych z podziałem na operacje porównania, zamiany miejsc oraz przypisania. Dodatkowo badano łączną liczbę wykonanych operacji jako sumę ważoną liczby operacji atomowych.\\

Przy losowych danych wejściowych (\ref{fig:quick-sort-deterministic-pivot-random}), czyli przypadku średniego w klasycznym algorytmie Quick Sort, partycjonowanie metodą Hoarego jest wydajniejsze lub tak samo wydajne jak partycjonowanie metodą Lemuto. Najlepsze wyniki otrzymano poprzez połączenie partycjonowania metodą Hoarego z wyborem pivota jako ostatni element tablicy. Najgorsze wyniki otrzymano wybierając pivot jako mediana-median z pięciu, przy czym najgorszy wynik osiągnięto niezależnie od wyboru metody partycjonowania.\\

Przy danych wejściowych posortowanych w odwrotnej kolejności (\ref{fig:quick-sort-deterministic-pivot-reversed}), czyli dla przypadku pesymistycznego w klasycznym algorytmie Quick Sort, partycjonowanie metodą Hoarego jest również wydajniejsze lub tak samo wydajne jak partycjonowanie metodą Lemuto. Najlepsze wyniki otrzymano poprzez połączenie partycjonowania metodą Hoarego z wyborem pivota jako mediana z trzech. Najgorsze wyniki otrzymano dla klasycznego algorytmu Quick Sort, czyli poprzez połączenia partycjonowania metodą Lemuto z wyborem pivota jako ostatni element tablicy.\\

Porównując liczbę wykonanych operacji pomiędzy badanymi algorytmami partycjonowania (\ref{fig:quick-sort-deterministic-pivot-all}) można stwierdzić, że partycjonowanie metodą Hoare wykonuje większą liczbę operacji porównania oraz mniejszą liczbę operacji zamiany miejsc. Czynnik ten może okazać się szczególnie istotny w przypadku sortowania złożonych struktur, dla których czas porównania dwóch elementów jest znacznie dłuższy.\\
 
Do analizy rozkładu prawdopodobieństwa liczby wykonanych operacji (\ref{fig:quick-sort-deterministic-pivot-density}) użyto tablicy losowych danych o stałym rozmiarze $n = 1000$. Dla badanych algorytmów najmniejsze odchylenie standardowe mają algorytmy partycjonowania metodą Hoare przy wyborze pivota jako pseudo-mediana z dziewięciu lub mediana-median z trzech. Największe odchylenie standardowe występuje dla klasycznego algorytmu Quick Sort. Najmniejsza wartość oczekiwana liczby wykonanych operacji jest osiągana poprzez patycjonowanie metodą Hoare z wyborem pivota jako ostatni element tablicy.

% tabelka, procentowo średnia liczba wykonanych operacji dla każdej z metod przy stałym rozmiarze tablicy n = 1000
% tabelka, wyliczone odchylenie standardowe oraz wartość oczekiwana dla poszczególnych algorytmów
% Wykres porownujacy roznice pomiedzy przypadkiem srednim a pesymistycznym

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=0.8\columnwidth]{img/plot/quick-sort-deterministic-pivot-random.svg}
	\caption[]{}
	\label{fig:quick-sort-deterministic-pivot-random}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=0.8\columnwidth]{img/plot/quick-sort-deterministic-pivot-reversed.svg}
	\caption[]{}
	\label{fig:quick-sort-deterministic-pivot-reversed}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=0.8\columnwidth]{img/plot/quick-sort-deterministic-pivot-density.svg}
	\caption[]{}
	\label{fig:quick-sort-deterministic-pivot-density}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.1\columnwidth]{img/plot/quick-sort-deterministic-pivot-random-all.svg}
	\caption[]{}
	\label{fig:quick-sort-deterministic-pivot-all}
\end{figure}

\subsection{Wnioski}
W badanych implementacjach algorytmów z rodziny Quick Sort, partycjonowanie metodą Hoare okazało się wydajniejsze niż partycjonowanie metodą Lemuto. Ponieważ partycjonowanie metodą Hoare wykonuje większą liczbę operacji porównania niż partycjonowanie metodą Lemuto, algorytm ten nadaje się do sortowania kolekcji zawierającej dane prymitywne, jednak w przypadku sortowania bardziej złożonych struktur metoda ta może okazać się mniej wydajna.\\

Analizując zachowanie algorytmów można stwierdzić, że dla danych posortowanych lub prawie posortowanych, dobrym wyborem jest skorzystanie z kosztownej metody wyszukiwania pivota, która pomimo swojego dodatkowego nakładu czasowego zwiększa prawdopodobieństwo na znalezienie dobrego pivota. Wyjątkiem jest wybór pivota jako mediana-median z pięciu, w przypadku którego dodatkowy nakład czasowy sprawia, że algorytm jest znacznie mniej wydajny nawet dla uporządkowanych danych wejściowych. Przez pojęcie \BOLD{dobrego pivota} rozumiemy tutaj pozycję możliwie blisko środka partycjonowanej tablicy.\\

\section{Rodzina randomizowanych algorytmów Quick Sort}
Klasyczny algorytm Quick Sort kiepsko sobie radzi z uporządkowanymi lub prawie uporządkowanymi danymi wejściowymi. W najmniej skutecznym wariancie, tzn. podczas wyboru pivota jako ostatni element tablicy, algorytm ten działa ze złożonością czasową $O(n^2)$. W przypadku uporządkowanych danych wejściowych skutecznym sposobem może okazać się niedeterministyczny wybór pivota. W tym rozdziale dokonano analizy randomizowanych algorytmów z rodziny Quick Sort, z podziałem na metody partycjonowania Lemuto oraz Hoarego. W analizie wykorzystano następujące metody wyboru pivota:

\begin{itemize}
	\setlength\itemsep{0em}
	\item \BOLD{losowy element} - pivotem jest losowo wybrany element tablicy,
	\item \BOLD{mediana z trzech wyborów} - przystosowanie meotdy \BOLD{power of two choices} do potrzeby wyznaczania mediany, pivotem jest mediana z trzech losowo wybranych elementów,
	\item \BOLD{pseudo-mediana z dziewięciu wyborów} - pivotem jest mediana z dziewięciu losowo wybranych elementów.\\
\end{itemize}

\subsection{Analiza porównawcza algorytmów}
Tak jak w poprzednim rozdziale, algorytmy były analizowane pod kątem liczby wykonywanych operacji atomowych, z podziałem na operacje porównania, zamiany miejsc oraz przypisania. Dodatkowo badano łączną liczbę wykonanych operacji jako sumę ważoną liczby operacji atomowych.\\

Przy losowych danych wejściowych (\ref{fig:quick-sort-nondeterministic-pivot-random}) większość randomizowanych metod wyboru pivota okazuje się mniej skuteczna od klasycznego algorytmu Quick Sort. Przy partycjonowaniu metodą Lemuto jedyną skuteczniejszą metodą jest wybór pivota jako mediana z trzech losowych elementów. Przy partycjonowaniu metodą Hoarego, najskuteczniejszym okazuje się wybór za pivota losowego elementu tablicy. Połączenie metody Hoarego z losowym wyborem pivota jest również najskuteczniejszym podejściem podczas sortowania losowych danych. Najmniej wydajną strategią sortowania okazał się wybór pivota jako pseudo-mediana z dziewięciu losowych elementów, przy czym najgorszy wynik osiągnięto dla obydwu metod partycjonowania.\\

Przy danych wejściowych posortowanych w odwrotnej kolejności (\ref{fig:quick-sort-nondeterministic-pivot-reversed}), czyli dla przypadku pesymistycznego w klasycznym algorytmie Quick Sort, najskuteczniejszą strategią sortowania również okazało się partycjonowanie metodą Hoarego przy wyborze pivota jako losowy element tablicy. Spośród randomizowanych strategii sortowania najmniej wydajną okazał się wybór pivota jako pseudo-mediana z dziewięciu losowych elementów. W przypadku danych wejściowych posortowanych w odwrotnej kolejności, każda ze strategii randomizowanych jest wydajniejsza od klasycznego podejścia w metodzie Quick Sort.\\

Porównując liczbę wykonanych operacji (\ref{fig:quick-sort-nondeterministic-pivot-random-all}) można stwierdzić, że dla dowolnych randomizowanych strategii wyboru pivota, partycjonowanie metodą Hoare wykonuje większą liczbę operacji porównania oraz mniejszą liczbę operacji zamiany miejsc. Tak jak w przypadku algorytmów deterministycznych, czynnik ten może okazać się istotny w przypadku sortowania złożonych struktur.\\

Badając rozkład prawdopodobieństwa liczby wykonanych operacji dla algorytmów randomizowanych,

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-sort-nondeterministic-pivot-random.svg}
	\caption[]{}
	\label{fig:quick-sort-nondeterministic-pivot-random}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-sort-nondeterministic-pivot-reversed.svg}
	\caption[]{}
	\label{fig:quick-sort-nondeterministic-pivot-reversed}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.1\columnwidth]{img/plot/quick-sort-nondeterministic-pivot-random-all.svg}
	\caption[]{}
	\label{fig:quick-sort-nondeterministic-pivot-random-all}
\end{figure}

\subsection{Wnioski}

\section{QuickMerge Sort}
Koncepcja algorytmu, mocne strony (Merge Sort bez konieczności alokacji pamięci)

\subsection{Pseudokod}

\subsection{Analiza algorytmu}
Wykresy liczby wykonywanych operacji w porównaniu do algorytmów bazowych.
Wykresy gęstości liczby wykonywanych operacji dla stałej liczby n, np n = 10000.

\subsection{Wnioski}
Wyniki analizy porównawczej


\section{Intro Sort}
Ogólny opis algorytmu, gdzie jest wykorzystywany (std::sort w g++), zalety.
% TODO sprawdzic jakiego algorytmu partycjonowania uzywaja w srodku i spróbować podmienić, zmienic na wariacje z randomowym
% wyborem pivota
\subsection{Pseudokod}

\subsection{Analiza algorytmu}
Wykresy liczby wykonywanych operacji w porównaniu do algorytmów bazowych.
Wykresy gęstości liczby wykonywanych operacji dla stałej liczby n, np n = 10000.
Wykresy dla różnych algorytmów partycjonowania.

\subsection{Wnioski}
Wyniki analizy porównawczej

% TODO jak zdaze proba modyfikacji algorytmu intro sort

% TODO jak zdaze dodac Quick Heap Sort

% TODO merge sort na wiele czesci
