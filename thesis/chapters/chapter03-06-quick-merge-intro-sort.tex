\newpage
\section{QuickMergeIntro Sort}
W poprzednich rozdziałach omówione zostały algorytmy Intro Sort oraz QuickMerge Sort. Algorytm Intro Sort rozwiązuje problem pesymistycznej złożoności obliczeniowej obecny w klasycznym algorytmie Quick Sort. Z kolei algorytm QuickMerge Sort optymalizuje liczbę wykonywanych operacji porównania, przez co jest niezwykle wydajny podczas sortowania złożonych typów danych. W tym rozdziale podjęto próbę połączenia tych dwóch technik, tworząc algorytm QuickMergeIntro Sort.\\

Algorytm QuickMergeIntro Sort, tak jak algorytm Intro Sort, zmienia swoje działanie w zależności od czynników zewnętrznych. Jeśli rozmiar tablicy jest mniejszy od punktu granicznego, tablica jest sortowana metodą Insertion Sort. Jeśli przekroczono maksymalną głębokość drzewa wywołań rekurencyjnych, tablica jest sortowana algorytmem Heap Sort. W przeciwnym wypadku, jeśli żaden w powyższych warunków nie zachodzi, stosowane jest podejście znane z algorytmu QuickMerge Sort. Algorytm partycjonujący dzieli tablicę wejściową na dwie części, z których mniejsza jest sortowana metodą Merge Sort, zaś pozostała jest sortowana rekurencyjnie algorytmem QuickMergeIntro Sort.\\

Ponieważ stosowanie algorytmu QuickMerge Sort przynosi realne korzyści podczas sortowania złożonych struktur danych, w testach założono, że współczynnik kosztu ma wartość $\alpha = 10.0$. Przeprowadzane wcześniej testy sugerują, że dla złożonych struktur danych partycjonowanie metodą Lomuto osiąga lepsze rezultaty niż partycjonowanie metodą Hoare. Z tego powodu w analizie uwzględniono tylko pierwszą z przedstawionych metod. Dodatkowo w analizie zrezygnowano ze strategii wyboru piwota jako mediana-median, które dla poprzednich testów okazały się niewydajne, powodując dodatkowy nakład obliczeniowy.\\

\subsection{Pseudokod}

Podobnie jak w przypadku algorytmu Intro Sort, algorytm QuickMergeIntro Sort można podzielić na trzy rozłączne etapy. Wybór etapu uzależniony jest od wielkości tablicy wejściowej oraz głębokości drzewa wywołań rekurencyjnych. Dla tablicy o rozmiarze nieprzekraczającym punktu granicznego, dane są sortowane algorytmem Insertion Sort (linia \ref{line:qmi-insertion-sort}). Dla tablicy rozmiaru powyżej punktu granicznego, w przypadku gdy przekroczono maksymalną głębokość drzewa wywołań rekurencyjnych, stosowany jest algorytm Heap Sort (linia \ref{line:qmi-heap-sort}). Jeśli żaden z powyższych przypadków nie zachodzi, stosowane jest podejście znane z algorytmu QuickMerge Sort (linia \ref{line:quick-merge-intro-sort}). Tablica wejściowa jest partycjonowana, zaś krótsza z partycji jest sortowana metodą Merge Sort. Tak jak w przypadku algorytmu QuickMerge Sort, bufor służący do scalania tablicy wynikowej stanowi druga partycja. Na koniec druga partycja zostaje posortowana algorytmem QuickMergeIntro Sort, przy czym każdemu rekurencyjnemu wywołaniu towarzyszy dekrementacja głębokości drzewa.\\

\input{chapters/pseudocodes/quick-merge-intro-sort}

\subsection{Analiza deterministycznych wersji algorytmu QuickMergeIntro Sort}
Analizując wydajność deterministycznych algorytmów z rodziny QuickMergeIntro Sort, badano liczbę wykonywanych operacji atomowych z podziałem na operacje porównania, zamiany miejsc oraz przypisania. W testach przyjęto stałą wartość współczynnika kosztu równą $\alpha = 10.0$. Dodatkowo we wszystkich testach zastosowano partycjonowanie metodą Lomuto.\\

Badając liczbę wykonanych operacji dla losowych danych wejściowych (\ref{fig:quick-merge-intro-sort-deterministic-pivot-random-sorted}) można zauważyć, że połączenie algorytmu QuickMergeIntro Sort z wyborem piwota jako mediana z trzech lub pseudo-mediana z dziewięciu elementów, osiąga podobne rezultaty co zastosowanie algorytmu QuickMerge Sort. Dodatkowo, algorytm QuickMergeIntro Sort dla złożonych struktur danych jest wydajniejszy od algorytmu Intro Sort.\\

Analizując liczbę wykonanych operacji dla uporządkowanych danych wejściowych (\ref{fig:quick-merge-intro-sort-deterministic-pivot-random-sorted}), podobnie jak w przypadku danych losowych, można zauważyć że połączenie algorytmu QuickMergeIntro Sort z wyborem piwota jako mediana z trzech lub pseudo-mediana z dziewięciu elementów, prowadzi do zbliżonych rezultatów co zastosowanie algorytmu QuickMerge Sort. W tym przypadku zastosowanie strategii wyboru piwota jako ostatni element tablicy powoduje drastyczny wzrost złożoności obliczeniowej.\\

Badając średnią liczbę wykonanych operacji dla losowych danych wejściowych (\ref{fig:quick-merge-intro-sort-deterministic-pivot-density}), porównywano różne wersje algorytmu QuickMergeIntro Sort z algorytmami QuickMerge Sort oraz Intro Sort. W przypadku dwóch ostatnich, zastosowano wybór piwota jako pseudo-mediana z dziewięciu elementów. Analiza eksperymentalna sugeruje, że dla złożonych danych wejściowych, połączenie algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako pseudo-mediana z dziewięciu elementów jest nieznacznie wydajniejsze od algorytmu QuickMerge Sort oraz sporo wydajniejsze od swojego odpowiednika Intro Sort.\\ 

Analizując średnią liczbę wykonanych operacji dla uporządkowanych danych wejściowych (\ref{fig:quick-merge-intro-sort-deterministic-pivot-density}), również porównywano wariacje algorytmu QuickMergeIntro Sort z algorytmami QuickMerge Sort oraz Intro Sort. Dla algorytmów QuickMerge Sort oraz Intro Sort zastosowano wybór piwota jako mediana z trzech elementów. Analiza eksperymentalna sugeruje, że podczas sortowania uporządkowanych danych wejściowych, połączenie algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako mediana z trzech elementów jest wydajniejsze od algorytmów QuickMerge Sort oraz Intro Sort.\\

Badając średnią liczbę wykonanych operacji z rozbiciem na poszczególne operacje (\ref{fig:quick-merge-intro-sort-deterministic-pivot-density-sorted}), pominięto operacje przypisania, które w większości badanych przypadków były bliskie zeru. Można zauważyć, że połączenie algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako pseudo-mediana z dziewięciu elementów, wykonuje nieznacznie mniejszą liczbę operacji porównania od swojego odpowiednika QuickMerge Sort. Wszystkie badane wersje algorytmu QuickMergeIntro Sort wykonywały zbliżoną liczbę operacji zamiany miejsc. Najmniejsze odchylenie standardowe zaobserwowano dla algorytmu QuickMerge Sort.\\

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-merge-intro-sort-deterministic-pivot-random-sorted.svg}
	\caption[]{}
	\label{fig:quick-merge-intro-sort-deterministic-pivot-random-sorted}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-merge-intro-sort-deterministic-pivot-density.svg}
	\caption[]{}
	\label{fig:quick-merge-intro-sort-deterministic-pivot-density}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-merge-intro-sort-deterministic-pivot-density-sorted.svg}
	\caption[]{}
	\label{fig:quick-merge-intro-sort-deterministic-pivot-density-sorted}
\end{figure}

\subsection{Analiza randomizowanych wersji algorytmu QuickMergeIntro Sort}
Analizując wydajność randomizowanych algorytmów z rodziny QuickMergeIntro Sort, badano liczbę wykonywanych operacji atomowych z podziałem na operacje porównania, zamiany miejsc oraz przypisania. W testach przyjęto stałą wartość współczynnika kosztu równą $\alpha = 10.0$. Dodatkowo we wszystkich testach zastosowano partycjonowanie metodą Lomuto.\\

Badając liczbę wykonanych operacji dla losowych danych wejściowych (\ref{fig:quick-merge-intro-sort-nondeterministic-pivot-random-sorted}) można zauważyć, podobnie jak w przypadku algorytmów deterministycznych, że połączenie algorytmu QuickMergeIntro Sort z wyborem piwota jako mediana z trzech lub pseudo-mediana z dziewięciu losowych elementów, osiąga podobne rezultaty co odpowiednik QuickMerge Sort. W tym przypadku, wybór piwota jako losowy element tablicy okazał się mniej wydajną strategią. Dodatkowo, dla złożonych typów danych, każda z badanych wariacji algorytmu QuickMergeIntro Sort osiąga lepsze rezultaty od algorytmu Intro Sort.\\

Analizując liczbę wykonanych operacji dla uporządkowanych danych wejściowych (\ref{fig:quick-merge-intro-sort-nondeterministic-pivot-random-sorted}), można zauważyć że połączenie algorytmu QuickMergeIntro Sort z wyborem piwota jako pseudo-mediana z dziewięciu losowych elementów, osiąga zbliżonych rezultaty co algorytm QuickMerge Sort. Co ciekawe, w przypadku algorytmów randomizowanych, zastosowanie strategii wyboru piwota jako mediana z trzech losowych elementów okazało się mniej wydajne.\\

Badając średnią liczbę wykonanych operacji dla losowych danych wejściowych (\ref{fig:quick-merge-intro-sort-nondeterministic-pivot-density}), porównywano różne wersje algorytmu QuickMergeIntro Sort z algorytmami QuickMerge Sort oraz Intro Sort. W przypadku dwóch ostatnich, zastosowano wybór piwota jako pseudo-mediana z dziewięciu losowych elementów. Analiza eksperymentalna sugeruje, że dla złożonych danych wejściowych, połączenie algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako pseudo-mediana z dziewięciu losowych elementów jest nieznacznie wydajniejsze od randomizowanego algorytmu QuickMerge Sort oraz sporo wydajniejsze od swojego odpowiednika Intro Sort. Jednocześnie, przedstawione podejście z wykorzystaniem algorytmu QuickMergeIntro Sort jest najwydajniejszym badanym sposobem na sortowanie złożonych struktur losowych danych.\\ 

Analizując średnią liczbę wykonanych operacji dla uporządkowanych danych wejściowych (\ref{fig:quick-merge-intro-sort-nondeterministic-pivot-density}), również porównywano wariacje algorytmu QuickMergeIntro Sort z randomizowanymi algorytmami QuickMerge Sort oraz Intro Sort. Dla algorytmów QuickMerge Sort oraz Intro Sort zastosowano wybór piwota jako pseudo-mediana z dziewięciu losowych elementów. Analiza eksperymentalna sugeruje, że podczas sortowania uporządkowanych danych wejściowych, połączenie algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako pseudo-mediana z dziewięciu losowych elementów jest wydajniejsze od algorytmów QuickMerge Sort oraz Intro Sort. Korzystając z algorytmu QuickMerge Sort otrzymano nieznacznie mniejsze odchylenie standardowe.\\

Badając średnią liczbę wykonanych operacji z rozbiciem na poszczególne operacje (\ref{fig:quick-merge-intro-sort-nondeterministic-pivot-density-sorted}), pominięto operacje przypisania, które w większości badanych przypadków były bliskie zeru. Można zauważyć, że połączenie algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako pseudo-mediana z dziewięciu elementów, wykonuje nieznacznie mniejszą liczbę operacji porównania od swojego odpowiednika QuickMerge Sort. Co ciekawe, stosując tę strategię otrzymano najmniejsze odchylenie standardowe liczby wykonywanych operacji spośród badanych algorytmów z rodziny QuickMergeIntro Sort. Analizując liczbę operacji zamiany miejsc, najwydajniejsza badana wersja algorytmu QuickMergeIntro Sort osiągnęła zbliżoną wydajność co odpowiednik QuickMerge Sort.\\

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-merge-intro-sort-nondeterministic-pivot-random-sorted.svg}
	\caption[]{}
	\label{fig:quick-merge-intro-sort-nondeterministic-pivot-random-sorted}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-merge-intro-sort-nondeterministic-pivot-density.svg}
	\caption[]{}
	\label{fig:quick-merge-intro-sort-nondeterministic-pivot-density}
\end{figure}

\begin{figure}[]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/plot/quick-merge-intro-sort-nondeterministic-pivot-density-sorted.svg}
	\caption[]{}
	\label{fig:quick-merge-intro-sort-nondeterministic-pivot-density-sorted}
\end{figure}

\subsection{Wnioski}
Ponieważ algorytm QuickMerge Sort minimalizuje liczbę wykonywanych operacji porównania, zaś algorytm Intro Sort optymalizuje łączną liczbę operacji, spodziewano się że połączenie tych dwóch algorytmów doprowadzi do jeszcze większego wzrostu wydajności, szczególnie podczas sortowania złożonych struktur danych.\\

Przeprowadzona analiza eksperymentalna sugeruje, że istnieją warianty algorytmu QuickMerge Sort, które są wydajniejsze zarówno od QuickMerge Sort, jak i Intro Sort. Dla złożonych danych wejściowych w losowej kolejności, najwydajniejszym algorytmem sortującym jest randomizowana wersja algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako pseudo-mediana z dziewięciu losowych elementów.\\

Sortując uporządkowany ciąg złożonych struktur, najwydajniejszą spośród badanych strategii jest połączenie deterministycznego algorytmu QuickMergeIntro Sort z partycjonowaniem metodą Lomuto oraz wyborem piwota jako mediana z trzech elementów. Ponieważ przedstawione strategie osiągają wyniki lepsze niż algorytm QuickMerge Sort, metody te są sugerowanym podejściem podczas sortowania tablicy złożonych danych wejściowych.\\ 
