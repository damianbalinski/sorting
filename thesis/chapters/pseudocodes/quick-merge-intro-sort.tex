\begin{algorithm}[H]
	\unboldmath
	\thinmuskip=6mu
	\caption{QuickMergeIntro Sort}
	\begin{algorithmic}[1]
		\Procedure{QuickMergeIntroSort(arr, depth)}{}
		
		\State
		\If {$\FUNC{len}{\VAR{arr}} \leq \VAR{maxLength}$} \Comment{sortowanie przez wstawianie} \label{line:qmi-insertion-sort}
		\State $\CALL{InsertionSort}{\VAR{arr}}$
		
		\State
		\ElsIf {$\VAR{depth} = 0$} \Comment{sortowanie przez kopcowanie} \label{line:qmi-heap-sort}
		\State $\CALL{HeapSort}{\VAR{arr}}$
		
		\State
		\Else \label{line:quick-merge-intro-sort}
		\State $\VAR{arr}_1, \VAR{arr}_2 \gets \CALL{Partition}{\VAR{arr}}$ \Comment{partycjonowanie}
		
		\State
		\If {$\FUNC{len}{\VAR{arr}_1} < \FUNC{len}{\VAR{arr}_2}$} \Comment{sortowanie}
		\State $\VAR{buffer} \gets \VAR{arr}_2$
		\State $\CALL{MergeSortBySwaps}{\VAR{arr}_1, \VAR{buffer}}$
		\State $\CALL{QuickMergeIntroSort}{\VAR{arr}_2, \VAR{depth-1}}$
		\Else
		\State $\VAR{buffer} \gets \VAR{arr}_1$
		\State $\CALL{MergeSortBySwaps}{\VAR{arr}_2, \VAR{buffer}}$
		\State $\CALL{QuickMergeIntroSort}{\VAR{arr}_1, \VAR{depth-1}}$
		\EndIf
		\EndIf
		
		\State
		\EndProcedure
	\end{algorithmic}
	\boldmath
	\thinmuskip=3mu
	\label{pseudocode:quick-merge-intro-sort}
\end{algorithm}
