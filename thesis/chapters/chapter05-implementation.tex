\chapter{Implementacja systemu}
\thispagestyle{chapterBeginStyle}


\section{Struktura systemu}
Aplikacja składa się z dwóch modułów: silnika testującego oraz silnika graficznego.
Działanie systemu jest określane na podstawie współdzielonego pliku konfiguracyjnego. W pliku konfiguracyjnym
określone są rodzaje testów jakie należy przeprowadzić oraz metadane potrzebne do wygenerowania wizualizacji.\\

Silnik testujący to generyczna biblioteka algorytmów sortujących oraz narzędzie przetwarzające
te algorytmy. Aplikacja w oparciu o plik konfiguracyjny generuje zestaw testowy oraz utrwala
wyniki przeprowadzonych testów na dysku. W zależności od konfiguracji, silnik testujący może
sumować, zliczać lub uśredniać liczbę wykonywanych operacji takich jak: liczba porównań, liczba
operacji zamiany miejsc, liczba operacji przypisania oraz czas trwania algorytmu. Ta część aplikacji
została napisana w języku C++ \footnote{Dokumentacja języka C++: \url{https://en.cppreference.com}}
z wykorzystaniem technik programowania obiektowego.\\

Silnik graficzny to zbiór skryptów przetwarzających wyniki z silnika testującego. Na podstawie pliku
konfiguracyjnego oraz danych testowych generowane są wizualizacje graficzne w postaci wykresów, dzięki
czemu użytkownik końcowy może w łatwy sposób analizować oraz porównywać badane algorytmy. Ta część
systemu została napisana w języku Python \footnote{Dokumentacja języka Python: \url{https://docs.python.org/3/}}
przy użyciu biblioteki matplotlib \footnote{Dokumentacja biblioteki matplotlib: \url{https://matplotlib.org/}}.


\section{Koncepcje architektury silnika testującego}

\subsection{Wstrzykiwanie zależności}
Większość algorytmów sortujących składa się z kilku odrębnych kroków. Niektóre z tych kroków są na tyle
złożone, że stanowią osobne algorytmy. Dla przykładu jednym etapów sortowania metodą Quick Sort
jest partycjonowanie danych wejściowych na rozłączne zbiory. Aby w łatwy sposób umożliwić modyfikację
testowanych algorytmów, bez konieczności ponownej implementacji całego procesu, zastosowano technikę
wstrzykiwania zależności. Jeżeli algorytm testujący korzysta z innego algorytmu, to algorytm składowy
jest wstrzykiwany w trakcie działania programu. Dzięki temu lekka modyfikacja testowanego algorytmu
ogranicza się do podmiany jego algorytmów składowych, bez konieczności ingerowania w strukturę bazową.

\subsection{Obiektowość}
Aby uprościć organizację kodu zastosowano model obiektowy. Każdy z algorytmów wykorzystywanych w systemie
został zamodelowany za pomocą odrębnej klasy. Dla każdej rodziny algorytmów tego samego typu istnieje
nadrzędna klasa bazowa określająca interfejs dla tej rodziny. Korzyści wynikające z zastosowanego
modelu, takie jak statyczny polimorfizm oraz dziedziczenie, gwarantują bardziej wiarygodne działanie programu
oraz umożliwiają wykrywanie błędów strukturalnych już na etapie kompilacji projektu.

\subsection{Bezstanowość}
Powszechnym problemem w programowaniu obiektowym jest przechowywanie stanu. Problem ten wynika po części
z praktyki hermetyzacji danych wewnątrz obiektowej abstrakcji. Użytkownik zewnętrzny korzystając z interfejsu
danego komponentu nie ma dostępu do procesów zachodzących w jego wnętrzu. Może to prowadzić do tzw. efektów
ubocznych (ang. side effects), przez co wyniki zwracane przez program stają się niewiarygodne.\\

Aby tego uniknąć zastosowano model bezstanowy. Żaden z algorytmów sortujących w zaimplementowanym systemie
nie posiada zmiennych składowych, które mogły by zostać zmodyfikowane w trakcie działania programu. Podczas
testowania dane są przekazywane poprzez sygnatury metod, wzorując się na technice programowania funkcyjnego.
Dzięki temu wszystkie algorytmy sortujące wykorzystane w implementacji są oznaczone jako niemodyfikowalne,
nie mogą zmienić stanu aktualnie testowanego algorytmu. Gwarantuje to całkowitą separację poszczególnych testów.

\section{Model aplikacji}
% rozbicie na wstrzykiwane komponenty

\subsection{Diagram klas}
TODO: opis diagramu
% Model UML systemu

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false,width=1.0\columnwidth]{img/uml/project-class-diagram.svg}
	\caption{Diagram klas silnika testującego}
\end{figure}

\subsection{Diagram aktywności}
TODO: opis diagramu
% na wejściu przyjmuje konfigurację, w oparciu o konfigurację wywołuje testy i zapisuje do pliku

\begin{figure}[H]
	\centering
	\subfloat[\centering silnik testujący]{
		\includesvg[inkscapelatex=false,width=0.45\columnwidth]{img/uml/testing-engine-activity-diagram.svg}
	}
	\qquad
	\subfloat[\centering silnik graficzny]{
		\includesvg[inkscapelatex=false,width=0.45\columnwidth]{img/uml/graphic-engine-activity-diagram.svg}
	}
	\caption{Diagram aktywności projektowanego systemu}
\end{figure}

\section{Wzorce projektowe}

\subsection{Fasada}
W trakcie działania algorytm sortujący wykonuje wiele operacji atomowych, takich jak porównywanie
elementów, zamiana elementów miejscami oraz operacje przypisania. Aby uniknąć nadmiaru odpowiedzialności
dla klas sortujących zastosowano obiekt pośredniczący \BOLD{operation} będący równocześnie \BOLD{fasadą}.
Fasada zapewnia jednolity interfejs dla wszystkich operacji atomowych oraz przekierowuje ich działanie
do obiektów bezpośrednio odpowiedzialnych za ich wykonanie.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false,width=0.6\columnwidth]{img/uml/facade-design-pattern.svg}
\end{figure}

\subsection{Obiekt-Wartość}
Proces testowania algorytmu składa się z wielu iteracji. Każdy z atomowych testów wchodzących w skład
iteracji powinien być całkowicie niezależny i odseparowana od innych testów. Aby to zapewnić, dane pochodzące
z osobnych testów są przekazywane za pomocą \BOLD{obiektów-wartości}. Pola w takim obiekcie po
inicjalizacji stają się niemodyfikowalne. Użytkownik może jedynie odczytać ich wartość, bez możliwości ich modyfikacji. \BOLD{Obiekt-wartość} jest gwarancją, że wyniki pochodzące z testu są rzetelne oraz nie zostały
zmodyfikowane w trakcie przepływu danych pomiędzy procesami.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false,width=0.2\columnwidth]{img/uml/value-object-design-pattern.svg}
\end{figure}

\subsection{Strategia}
Aby wymusić działanie algorytmu w przypadku optymistycznym, pesymistycznym oraz średnim konieczne jest przygotowanie
spreparowanych danych, które powodują wystąpienie takiego przypadku. Aby to osiągnąć, dane testowe są tworzone za pomocą \BOLD{generatora}, który jest równocześnie \BOLD{strategią}. W zależności od zestawu testowego, używana jest inna strategia generowania danych, co przekłada się na późniejsze wyniki testowania.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false,width=0.65\columnwidth]{img/uml/strategy-design-pattern.svg}
\end{figure}

\subsection{Polecenie}
Aby możliwe było całościowe sparsowanie pliku konfiguracyjnego jeszcze przed wykonaniem testów, algorytmy sortujące są utrwalane w pamięci w formie wzorca projektowego \BOLD{polecenia}. W trakcie parsowania, polecenia są kolejkowane w formie algorytmów sortujących, a następnie przekazywane do silnika testującego. W fazie testowania wykonywane są kolejne testy z przekazanej listy poleceń.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false,width=0.55\columnwidth]{img/uml/command-design-pattern.svg}
\end{figure}


